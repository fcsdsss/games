if not game:IsLoaded() then
	game.Loaded:Wait()
end

if not syn or not protectgui then
	getgenv().protectgui = function() end
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

local FindFirstChild = game.FindFirstChild
local GetPlayers = Players.GetPlayers
local RenderStepped = RunService.RenderStepped
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local getMousePosition = UserInputService.GetMouseLocation

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

Library.ShowToggleFrameInKeybinds = true

local Toggles = Library.Toggles
local Options = Library.Options

local PredictionAmount = 0.165 -- 将由滑块控制
local ValidTargetParts = { "头", "HumanoidRootPart" }

local ExpectedArguments = {
	FindPartOnRayWithIgnoreList = { ArgCountRequired = 3, Args = { "Instance", "Ray", "table", "boolean", "boolean" } },
	FindPartOnRayWithWhitelist = { ArgCountRequired = 3, Args = { "Instance", "Ray", "table", "boolean" } },
	FindPartOnRay = { ArgCountRequired = 2, Args = { "Instance", "Ray", "Instance", "boolean", "boolean" } },
	Raycast = { ArgCountRequired = 3, Args = { "Instance", "Vector3", "Vector3", "RaycastParams" } },
}

--// 辅助函数
local function getDirection(Origin, Position)
	return (Position - Origin).Unit * 1000
end

local function getPositionOnScreen(Vector)
	local Vec3, OnScreen = WorldToScreen(Camera, Vector)
	return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function IsPlayerVisible(Player)
	local PlayerCharacter = Player.Character
	local LocalPlayerCharacter = LocalPlayer.Character
	if not (PlayerCharacter and LocalPlayerCharacter) then return false end

	local targetPartName = Options.TargetPart.Value
	if targetPartName == "头" then targetPartName = "Head" end -- 内部名称转换
	local PlayerRoot = FindFirstChild(PlayerCharacter, targetPartName) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")
	if not PlayerRoot then return false end

	local CastPoints = { PlayerRoot.Position, LocalPlayerCharacter.PrimaryPart.Position }
	local IgnoreList = { LocalPlayerCharacter, PlayerCharacter }
	return #Camera:GetPartsObscuringTarget(CastPoints, IgnoreList) == 0
end

local function CalculateChance(Percentage)
	return math.random() <= Percentage / 100
end

local function ValidateArguments(Args, RayMethod)
	if #Args < RayMethod.ArgCountRequired then return false end
	for Pos, Argument in ipairs(Args) do
		if typeof(Argument) ~= RayMethod.Args[Pos] then return false end
	end
	return true
end

--// 主要目标获取函数
local function getClosestPlayer()
	local ClosestPlayerPart
	local ClosestDistance = Options.FOVRadius.Value

	for _, Player in ipairs(GetPlayers(Players)) do
		if Player ~= LocalPlayer and (not Toggles.TeamCheck.Value or Player.Team ~= LocalPlayer.Team) then
			local Character = Player.Character
			if Character then
				local Humanoid = FindFirstChild(Character, "Humanoid")
				if Humanoid and Humanoid.Health > 0 and (not Toggles.VisibleCheck.Value or IsPlayerVisible(Player)) then
					local targetPartValue = Options.TargetPart.Value
					local targetPartName = targetPartValue
					if targetPartValue == "头" then targetPartName = "Head" end

					local TargetPart = (targetPartValue == "随机" and (Character[ValidTargetParts[math.random(1, #ValidTargetParts)]])) or FindFirstChild(Character, targetPartName)

					if TargetPart then
						local ScreenPosition, OnScreen = getPositionOnScreen(TargetPart.Position)
						if OnScreen then
							local Distance = (getMousePosition() - ScreenPosition).Magnitude
							if Distance < ClosestDistance then
								ClosestDistance = Distance
								ClosestPlayerPart = TargetPart
							end
						end
					end
				end
			end
		end
	end
	return ClosestPlayerPart
end

local Window = Library:CreateWindow({
	Title = "通用静默自瞄",
	Footer = "优化",
	NotifySide = "Right",
	Center = true,
	AutoShow = true,
})

local Tabs = {
	Aim = Window:AddTab("自瞄", "crosshair"),
	Visuals = Window:AddTab("视觉", "eye"),
	Settings = Window:AddTab("设置", "settings"),
}

local MainGroup = Tabs.Aim:AddLeftGroupbox("主要功能")
MainGroup:AddToggle("Enabled", { Text = "启用静默自瞄", Default = false })
	:AddKeyPicker("AimKeybind", { Default = "RightAlt", Mode = "Toggle", SyncToggleState = true, Text = "启用/禁用自瞄" })

MainGroup:AddToggle("TeamCheck", { Text = "队伍检测 (不打队友)", Default = false })
MainGroup:AddToggle("VisibleCheck", { Text = "可见性检测 (不打墙后)", Default = false })
MainGroup:AddSlider("HitChance", { Text = "命中率", Default = 100, Min = 0, Max = 100, Rounding = 0, Suffix = "%" })

local TargetingGroup = Tabs.Aim:AddRightGroupbox("目标选择")
TargetingGroup:AddDropdown("TargetPart", { Text = "目标部位", Values = { "头", "HumanoidRootPart", "随机" }, Default = "HumanoidRootPart" })
TargetingGroup:AddDropdown("SilentAimMethod", {
	Text = "自瞄方法",
	Values = { "Raycast", "FindPartOnRay", "FindPartOnRayWithWhitelist", "FindPartOnRayWithIgnoreList", "Mouse.Hit/Target" },
	Default = "Raycast",
	Tooltip = "推荐 'Raycast'！'Mouse.Hit/Target' 模式可能干扰镜头移动！",
})

local PredictionGroup = Tabs.Aim:AddRightGroupbox("移动预判")
PredictionGroup:AddToggle("MouseHitPrediction", { Text = "启用移动预判", Default = false, Tooltip = "仅在自瞄方法为 'Mouse.Hit/Target' 时生效" })
PredictionGroup:AddSlider("MouseHitPredictionAmount", { Text = "预判强度", Min = 0.1, Max = 0.5, Default = 0.165, Rounding = 3 })
Options.MouseHitPredictionAmount:OnChanged(function(val) PredictionAmount = val end)

--// 视觉标签页
local FOVGroup = Tabs.Visuals:AddLeftGroupbox("范围圈 (FOV)")
FOVGroup:AddToggle("FOVVisible", { Text = "显示范围圈", Default = false })
	:AddColorPicker("FOVColor", { Default = Color3.fromRGB(255, 255, 255), Transparency = 0.5 })
FOVGroup:AddSlider("FOVRadius", { Text = "范围圈半径", Min = 10, Max = 800, Default = 130, Rounding = 0 })

local TargetVisGroup = Tabs.Visuals:AddLeftGroupbox("目标")
TargetVisGroup:AddToggle("ShowSilentAimTarget", { Text = "显示目标方框", Default = false })
	:AddColorPicker("TargetColor", { Default = Color3.fromRGB(255, 0, 0) })

local MenuSettings = Tabs.Settings:AddLeftGroupbox("菜单")
MenuSettings:AddLabel("菜单开关按键"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true })
Library.ToggleKeybind = Options.MenuKeybind
MenuSettings:AddButton("卸载脚本", function() Library:Unload() end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder("UniversalSilentAim/Configs_CN")
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig()

--// 创建绘制对象
local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 64
fov_circle.Filled = false
fov_circle.ZIndex = 9999

local target_box = Drawing.new("Square")
target_box.Thickness = 2
target_box.Filled = false
target_box.ZIndex = 9999
target_box.Size = Vector2.new(12, 12)

RenderStepped:Connect(function()
	fov_circle.Visible = Toggles.FOVVisible.Value
	if fov_circle.Visible then
		fov_circle.Radius = Options.FOVRadius.Value
		fov_circle.Color = Options.FOVColor.Value
		fov_circle.Transparency = 1 - Options.FOVColor.Transparency -- UI库透明度与Drawing相反
		fov_circle.Position = getMousePosition()
	end

	-- 目标方框
	local target = getClosestPlayer()
	target_box.Visible = Toggles.ShowSilentAimTarget.Value and Toggles.Enabled.Value and target
	if target_box.Visible then
		local TargetRoot = target.Parent:FindFirstChild("HumanoidRootPart") or target
		local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, TargetRoot.Position)
		target_box.Visible = IsOnScreen
		if IsOnScreen then
			target_box.Position = Vector2.new(RootToViewportPoint.X - 6, RootToViewportPoint.Y - 6) -- 居中方框
			target_box.Color = Options.TargetColor.Value
		end
	end
end)

--// 核心逻辑挂钩 (Hooks)
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(...)
	local method = getnamecallmethod()
	local args = { ... }
	local self = args[1]
	if Toggles.Enabled.Value and self == workspace and not checkcaller() and CalculateChance(Options.HitChance.Value) then
		local silentAimMethod = Options.SilentAimMethod.Value
		local targetPart = getClosestPlayer()
		if targetPart then
			if method == silentAimMethod and (method == "FindPartOnRay" or method == "FindPartOnRayWithIgnoreList" or method == "FindPartOnRayWithWhitelist") then
				local ray = args[2]
				args[2] = Ray.new(ray.Origin, getDirection(ray.Origin, targetPart.Position))
				return oldNamecall(unpack(args))
			elseif method == "Raycast" and silentAimMethod == "Raycast" then
				args[3] = getDirection(args[2], targetPart.Position)
				return oldNamecall(unpack(args))
			end
		end
	end
	return oldNamecall(...)
end)

local oldIndex
oldIndex = hookmetamethod(game, "__index", function(self, index)
	if Toggles.Enabled.Value and self == Mouse and not checkcaller() and Options.SilentAimMethod.Value == "Mouse.Hit/Target" then
		local targetPart = getClosestPlayer()
		if targetPart then
			local lower_index = index:lower()
			if lower_index == "target" then
				return targetPart
			elseif lower_index == "hit" then
				return Toggles.MouseHitPrediction.Value and (targetPart.CFrame + (targetPart.Velocity * PredictionAmount)) or targetPart.CFrame
			elseif lower_index == "unitray" then
				return Ray.new(self.Origin, (targetPart.Position - self.Origin.Position).Unit)
			end
		end
	end
	return oldIndex(self, index)
end)
