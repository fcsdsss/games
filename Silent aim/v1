if not game:IsLoaded() then
	game.Loaded:Wait()
end

if not syn or not protectgui then
	getgenv().protectgui = function() end
end

--// Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")

--// LocalPlayer & Camera
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Mouse = LocalPlayer:GetMouse()

--// Shortened Functions
local FindFirstChild = game.FindFirstChild
local GetPlayers = Players.GetPlayers
local RenderStepped = RunService.RenderStepped
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local getMousePosition = UserInputService.GetMouseLocation

--// Library Initialization
local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

-- For mobile-friendliness
Library.ShowToggleFrameInKeybinds = true

-- Get library's state tables
local Toggles = Library.Toggles
local Options = Library.Options

--// Core Silent Aim Variables
local PredictionAmount = 0.165 -- This will be controlled by a slider
local ValidTargetParts = { "Head", "HumanoidRootPart" }

--// Raycasting Argument Validation
local ExpectedArguments = {
	FindPartOnRayWithIgnoreList = {
		ArgCountRequired = 3,
		Args = { "Instance", "Ray", "table", "boolean", "boolean" },
	},
	FindPartOnRayWithWhitelist = {
		ArgCountRequired = 3,
		Args = { "Instance", "Ray", "table", "boolean" },
	},
	FindPartOnRay = { ArgCountRequired = 2, Args = { "Instance", "Ray", "Instance", "boolean", "boolean" } },
	Raycast = { ArgCountRequired = 3, Args = { "Instance", "Vector3", "Vector3", "RaycastParams" } },
}

--// Helper Functions
local function getDirection(Origin, Position)
	return (Position - Origin).Unit * 1000
end

local function getPositionOnScreen(Vector)
	local Vec3, OnScreen = WorldToScreen(Camera, Vector)
	return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function IsPlayerVisible(Player)
	local PlayerCharacter = Player.Character
	local LocalPlayerCharacter = LocalPlayer.Character

	if not (PlayerCharacter and LocalPlayerCharacter) then
		return false
	end

	local TargetPartName = Options.TargetPart.Value
	local PlayerRoot = FindFirstChild(PlayerCharacter, TargetPartName) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")

	if not PlayerRoot then
		return false
	end

	local CastPoints = { PlayerRoot.Position, LocalPlayerCharacter.PrimaryPart.Position }
	local IgnoreList = { LocalPlayerCharacter, PlayerCharacter }

	local ObscuringObjects = #Camera:GetPartsObscuringTarget(CastPoints, IgnoreList)
	return ObscuringObjects == 0
end

local function CalculateChance(Percentage)
	return math.random() <= Percentage / 100
end

local function ValidateArguments(Args, RayMethod)
	if #Args < RayMethod.ArgCountRequired then
		return false
	end
	for Pos, Argument in ipairs(Args) do
		if typeof(Argument) ~= RayMethod.Args[Pos] then
			return false -- Mismatch
		end
	end
	return true
end

--// Main Target Acquistion Function
local function getClosestPlayer()
	local ClosestPlayerPart
	local ClosestDistance = Options.FOVRadius.Value

	for _, Player in ipairs(GetPlayers(Players)) do
		if Player ~= LocalPlayer and (not Toggles.TeamCheck.Value or Player.Team ~= LocalPlayer.Team) then
			local Character = Player.Character
			if Character then
				local Humanoid = FindFirstChild(Character, "Humanoid")
				if Humanoid and Humanoid.Health > 0 and (not Toggles.VisibleCheck.Value or IsPlayerVisible(Player)) then
					local TargetPartName = Options.TargetPart.Value
					local TargetPart = (TargetPartName == "Random" and (Character[ValidTargetParts[math.random(1, #ValidTargetParts)]])) or FindFirstChild(Character, TargetPartName)

					if TargetPart then
						local ScreenPosition, OnScreen = getPositionOnScreen(TargetPart.Position)
						if OnScreen then
							local Distance = (getMousePosition() - ScreenPosition).Magnitude
							if Distance < ClosestDistance then
								ClosestDistance = Distance
								ClosestPlayerPart = TargetPart
							end
						end
					end
				end
			end
		end
	end
	return ClosestPlayerPart
end

--// Create UI
local Window = Library:CreateWindow({
	Title = "Universal Silent Aim",
	Footer = "github.com/Averiias",
	NotifySide = "Right",
	Center = true,
	AutoShow = true,
})

local Tabs = {
	Aim = Window:AddTab("Aim", "crosshair"),
	Visuals = Window:AddTab("Visuals", "eye"),
	Settings = Window:AddTab("Settings", "settings"),
}

--// Aim Tab
local MainGroup = Tabs.Aim:AddLeftGroupbox("Main")

MainGroup:AddToggle("Enabled", { Text = "Enable Silent Aim", Default = false })
	:AddKeyPicker("AimKeybind", {
		Default = "RightAlt",
		Mode = "Toggle",
		SyncToggleState = true,
		Text = "Enable/Disable Aim",
		NoUI = false,
	})

MainGroup:AddToggle("TeamCheck", { Text = "Team Check", Default = false })
MainGroup:AddToggle("VisibleCheck", { Text = "Visibility Check", Default = false })
MainGroup:AddSlider("HitChance", {
	Text = "Hit Chance",
	Default = 100,
	Min = 0,
	Max = 100,
	Rounding = 0,
	Suffix = "%",
})

local TargetingGroup = Tabs.Aim:AddRightGroupbox("Targeting")

TargetingGroup:AddDropdown("TargetPart", {
	Text = "Target Part",
	Values = { "Head", "HumanoidRootPart", "Random" },
	Default = "HumanoidRootPart",
})

TargetingGroup:AddDropdown("SilentAimMethod", {
	Text = "Aim Method",
	Values = { "Raycast", "FindPartOnRay", "FindPartOnRayWithWhitelist", "FindPartOnRayWithIgnoreList", "Mouse.Hit/Target" },
	Default = "Raycast",
})

local PredictionGroup = Tabs.Aim:AddRightGroupbox("Prediction")
PredictionGroup:AddToggle("MouseHitPrediction", { Text = "Predict Movement", Default = false })
PredictionGroup:AddSlider("MouseHitPredictionAmount", {
	Text = "Prediction Amount",
	Min = 0.1,
	Max = 0.5,
	Default = 0.165,
	Rounding = 3,
})
Options.MouseHitPredictionAmount:OnChanged(function(val)
	PredictionAmount = val
end)


--// Visuals Tab
local FOVGroup = Tabs.Visuals:AddLeftGroupbox("Field of View")
FOVGroup:AddToggle("FOVVisible", { Text = "Show FOV Circle", Default = false }):AddColorPicker("FOVColor", { Default = Color3.fromRGB(54, 57, 241) })
FOVGroup:AddSlider("FOVRadius", {
	Text = "FOV Radius",
	Min = 10,
	Max = 500,
	Default = 130,
	Rounding = 0,
})

local TargetVisGroup = Tabs.Visuals:AddLeftGroupbox("Target")
TargetVisGroup:AddToggle("ShowSilentAimTarget", { Text = "Show Target Box", Default = false }):AddColorPicker("TargetColor", { Default = Color3.fromRGB(54, 57, 241) })


--// Settings Tab
local MenuSettings = Tabs.Settings:AddLeftGroupbox("Menu")
MenuSettings:AddLabel("Menu Toggle Key"):AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true })
Library.ToggleKeybind = Options.MenuKeybind
MenuSettings:AddButton("Unload Script", function()
	Library:Unload()
end)

--// Setup Addons
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder("UniversalSilentAim/Configs")

-- Build UI for addons
SaveManager:BuildConfigSection(Tabs.Settings)
ThemeManager:ApplyToTab(Tabs.Settings)
SaveManager:LoadAutoloadConfig() -- Load config marked as autoload

--// Drawing Objects for Visuals
local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Filled = false
fov_circle.Transparency = 1
fov_circle.ZIndex = 9999

local target_box = Drawing.new("Square")
target_box.Thickness = 2
target_box.Filled = false
target_box.ZIndex = 9999
target_box.Size = Vector2.new(10, 10)

--// Render Loop for Visuals
RunService.RenderStepped:Connect(function()
	-- FOV Circle
	fov_circle.Visible = Toggles.FOVVisible.Value
	if Toggles.FOVVisible.Value then
		fov_circle.Radius = Options.FOVRadius.Value
		fov_circle.Color = Options.FOVColor.Value
		fov_circle.Position = getMousePosition()
	end

	-- Target Box
	local target = getClosestPlayer()
	target_box.Visible = Toggles.ShowSilentAimTarget.Value and Toggles.Enabled.Value and target
	if target_box.Visible then
		local TargetRoot = target.Parent:FindFirstChild("HumanoidRootPart") or target
		local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, TargetRoot.Position)

		target_box.Visible = IsOnScreen
		if IsOnScreen then
			target_box.Position = Vector2.new(RootToViewportPoint.X - 5, RootToViewportPoint.Y - 5) -- Center the box
			target_box.Color = Options.TargetColor.Value
		end
	end
end)


--// Core Logic Hooks
-- __namecall hook for ray-based methods
local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", function(...)
	local method = getnamecallmethod()
	local args = { ... }
	local self = args[1]

	if Toggles.Enabled.Value and self == workspace and not checkcaller() and CalculateChance(Options.HitChance.Value) then
		local silentAimMethod = Options.SilentAimMethod.Value
		local targetPart = getClosestPlayer()

		if targetPart then
			if method == "FindPartOnRay" and silentAimMethod == "FindPartOnRay" and ValidateArguments(args, ExpectedArguments.FindPartOnRay) then
				local ray = args[2]
				args[2] = Ray.new(ray.Origin, getDirection(ray.Origin, targetPart.Position))
				return oldNamecall(unpack(args))
			elseif method == "FindPartOnRayWithIgnoreList" and silentAimMethod == "FindPartOnRayWithIgnoreList" and ValidateArguments(args, ExpectedArguments.FindPartOnRayWithIgnoreList) then
				local ray = args[2]
				args[2] = Ray.new(ray.Origin, getDirection(ray.Origin, targetPart.Position))
				return oldNamecall(unpack(args))
			elseif method == "FindPartOnRayWithWhitelist" and silentAimMethod == "FindPartOnRayWithWhitelist" and ValidateArguments(args, ExpectedArguments.FindPartOnRayWithWhitelist) then
				local ray = args[2]
				args[2] = Ray.new(ray.Origin, getDirection(ray.Origin, targetPart.Position))
				return oldNamecall(unpack(args))
			elseif method == "Raycast" and silentAimMethod == "Raycast" and ValidateArguments(args, ExpectedArguments.Raycast) then
				local origin = args[2]
				args[3] = getDirection(origin, targetPart.Position) -- Modify the direction vector
				return oldNamecall(unpack(args))
			end
		end
	end
	return oldNamecall(...)
end)

-- __index hook for Mouse.Hit/Target method
local oldIndex
oldIndex = hookmetamethod(game, "__index", function(self, index)
	if
		Toggles.Enabled.Value
		and self == Mouse
		and not checkcaller()
		and Options.SilentAimMethod.Value == "Mouse.Hit/Target"
	then
		local targetPart = getClosestPlayer()
		if targetPart then
			if index:lower() == "target" then
				return targetPart
			elseif index:lower() == "hit" then
				return Toggles.MouseHitPrediction.Value and (targetPart.CFrame + (targetPart.Velocity * PredictionAmount)) or targetPart.CFrame
			elseif index:lower() == "unitray" then
				return Ray.new(self.Origin, (targetPart.Position - self.Origin.Position).Unit)
			end
		end
	end
	return oldIndex(self, index)
end)
