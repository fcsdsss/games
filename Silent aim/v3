if not game:IsLoaded() then
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

local SilentAimSettings = {
    Enabled = false,
    ClassName = "Universal Silent Aim - Averiias, Stefanuk12, xaxa",
    ToggleKey = "RightAlt",
    TeamCheck = false,
    VisibleCheck = false,
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    FOVVisible = true,
    FOVShape = "Circle",
    FOVColor = Color3.fromRGB(54, 57, 241),
    ShowSilentAimTarget = false,
    TargetIndicatorShape = "Circle",
    TargetIndicatorColor = Color3.fromRGB(255, 0, 0),
    TargetIndicatorRadius = 20,
    ShowTracer = false,
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100,
    FixedFOV = true,
    MaxDistance = 500,
    Tracer_Y_Offset = 0
}

getgenv().SilentAimSettings = SilentAimSettings
local MainFileName = "UniversalSilentAim"

local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetPlayers = Players.GetPlayers
local WorldToViewportPoint = Camera.WorldToViewportPoint
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume
local create = coroutine.create

local ValidTargetParts = {"Head", "HumanoidRootPart"}
local PredictionAmount = 0.165
local currentTargetPart = nil

local FOVShapeObjects = {}
local TargetIndicatorObjects = {}

local distance_text = Drawing.new("Text")
distance_text.Visible = false
distance_text.ZIndex = 1001
distance_text.Font = Drawing.Fonts.Plex
distance_text.Size = 14
distance_text.Color = Color3.fromRGB(255, 255, 255)
distance_text.Center = true
distance_text.Outline = true

local tracer_line = Drawing.new("Line")
tracer_line.Visible = false
tracer_line.ZIndex = 998
tracer_line.Color = Color3.fromRGB(255, 255, 0)
tracer_line.Thickness = 1
tracer_line.Transparency = 1

local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean", "boolean"} },
    FindPartOnRayWithWhitelist = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean"} },
    FindPartOnRay = { ArgCountRequired = 2, Args = {"Instance", "Ray", "Instance", "boolean", "boolean"} },
    Raycast = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }
}

function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100
    return chance <= Percentage / 100
end

do
    if not isfolder(MainFileName) then makefolder(MainFileName) end
    if not isfolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) then
        makefolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId)))
    end
end

local function ClearDrawingObjects(objectTable)
    for _, obj in pairs(objectTable) do
        obj:Remove()
    end
    for i in pairs(objectTable) do
        objectTable[i] = nil
    end
end

function DrawShape(objectTable, center, radius, shape, color, thickness)
    thickness = thickness or 1
    local function create_line(from, to)
        local line = Drawing.new("Line")
        line.Thickness = thickness
        line.Color = color
        line.From = from
        line.To = to
        line.Visible = true
        table.insert(objectTable, line)
    end
    if shape == "Circle" then
        local circle = Drawing.new("Circle")
        circle.Thickness = thickness
        circle.Color = color
        circle.Radius = radius
        circle.Position = center
        circle.Filled = false
        circle.Visible = true
        table.insert(objectTable, circle)
    elseif shape == "Triangle" then
        local points = {
            center + Vector2.new(0, -radius),
            center + Vector2.new(-radius * 0.866, radius * 0.5),
            center + Vector2.new(radius * 0.866, radius * 0.5)
        }
        create_line(points[1], points[2])
        create_line(points[2], points[3])
        create_line(points[3], points[1])
    elseif shape == "Pentagram" then
        local points = {}
        for i = 0, 4 do
            local angle = math.rad(i * 72 - 90)
            points[i+1] = center + Vector2.new(math.cos(angle) * radius, math.sin(angle) * radius)
        end
        create_line(points[1], points[3])
        create_line(points[3], points[5])
        create_line(points[5], points[2])
        create_line(points[2], points[4])
        create_line(points[4], points[1])
    end
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToViewportPoint(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then return false end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then Matches = Matches + 1 end
    end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function getMousePosition()
    return GetMouseLocation(UserInputService)
end

local function IsPlayerVisible(Player)
    local localCharacter = LocalPlayer.Character
    local targetCharacter = Player.Character
    if not (localCharacter and targetCharacter) then return false end
    local targetPartName = SilentAimSettings.TargetPart
    if targetPartName == "Random" then targetPartName = "HumanoidRootPart" end
    local targetPart = targetCharacter:FindFirstChild(targetPartName) or targetCharacter:FindFirstChild("HumanoidRootPart")
    if not targetPart then return false end
    local cameraPosition = Camera.CFrame.Position
    local direction = targetPart.Position - cameraPosition
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Exclude
    raycastParams.FilterDescendantsInstances = {localCharacter}
    local raycastResult = workspace:Raycast(cameraPosition, direction.Unit * (direction.Magnitude + 5), raycastParams)
    return not raycastResult or raycastResult.Instance:IsDescendantOf(targetCharacter)
end

local function getClosestPlayer()
    local Closest, DistanceToAimPoint = nil, SilentAimSettings.FOVRadius
    local AimPoint
    local LocalPlayerCharacter = LocalPlayer.Character
    if not LocalPlayerCharacter then return nil end
    local localRoot = FindFirstChild(LocalPlayerCharacter, "HumanoidRootPart")
    if not localRoot then return nil end
    if SilentAimSettings.FixedFOV then AimPoint = Camera.ViewportSize / 2 else AimPoint = getMousePosition() end

    for _, Player in next, GetPlayers(Players) do
        if Player ~= LocalPlayer and not (SilentAimSettings.TeamCheck and Player.Team == LocalPlayer.Team) then
            local Character = Player.Character
            local targetRoot = Character and FindFirstChild(Character, "HumanoidRootPart")
            if Character and targetRoot then
                if SilentAimSettings.VisibleCheck and not IsPlayerVisible(Player) then continue end
                local distance = (localRoot.Position - targetRoot.Position).Magnitude
                if distance <= SilentAimSettings.MaxDistance then
                    local Humanoid = FindFirstChild(Character, "Humanoid")
                    if Humanoid and Humanoid.Health > 0 then
                        local TargetPartName = SilentAimSettings.TargetPart
                        local PartToAim = FindFirstChild(Character, TargetPartName)
                        if TargetPartName == "Random" then
                            PartToAim = Character[ValidTargetParts[math.random(1, #ValidTargetParts)]]
                        end
                        if PartToAim then
                            local ScreenPosition, OnScreen = getPositionOnScreen(PartToAim.Position)
                            if OnScreen then
                                local FovDistance = (AimPoint - ScreenPosition).Magnitude
                                if FovDistance <= DistanceToAimPoint then
                                    Closest, DistanceToAimPoint = PartToAim, FovDistance
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return Closest
end

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()
local Options, Toggles = Library.Options, Library.Toggles
local Window = Library:CreateWindow({Title = "Universal Silent Aim", Footer = "v2版本改自vapev4", Center = true, AutoShow = true})
local Tabs = {Main = Window:AddTab("Main", "user"), ["UI Settings"] = Window:AddTab("UI Settings", "settings")}
local MainGroupBox = Tabs.Main:AddLeftGroupbox("Main Settings", "boxes")

MainGroupBox:AddToggle("EnabledToggle",{Text = "Enabled",Default = SilentAimSettings.Enabled}):AddKeyPicker("EnabledKeybind",{Default = SilentAimSettings.ToggleKey,SyncToggleState = true,Mode = "Toggle"})
Toggles.EnabledToggle:OnChanged(function(v) SilentAimSettings.Enabled = v end)
MainGroupBox:AddToggle("TeamCheckToggle",{Text = "Team Check",Default = SilentAimSettings.TeamCheck})
Toggles.TeamCheckToggle:OnChanged(function(v) SilentAimSettings.TeamCheck = v end)
MainGroupBox:AddToggle("VisibleCheckToggle",{Text = "Visible Check",Default = SilentAimSettings.VisibleCheck})
Toggles.VisibleCheckToggle:OnChanged(function(v) SilentAimSettings.VisibleCheck = v end)
MainGroupBox:AddDropdown("TargetPartDropdown",{Values = {"Head", "HumanoidRootPart", "Random"},Default = SilentAimSettings.TargetPart,Text = "Target Part"})
Options.TargetPartDropdown:OnChanged(function(v) SilentAimSettings.TargetPart = v end)
MainGroupBox:AddDropdown("MethodDropdown",{Text = "Silent Aim Method",Default = SilentAimSettings.SilentAimMethod,Values = {"Raycast", "FindPartOnRay", "FindPartOnRayWithWhitelist", "FindPartOnRayWithIgnoreList", "ScreenPointToRay", "ViewportPointToRay", "Ray", "Mouse.Hit/Target"}})
Options.MethodDropdown:OnChanged(function(v) SilentAimSettings.SilentAimMethod = v end)
MainGroupBox:AddSlider('HitChanceSlider',{Text = 'Hit chance',Default = SilentAimSettings.HitChance,Min = 0,Max = 100,Rounding = 1,Suffix = "%"})
Options.HitChanceSlider:OnChanged(function(v) SilentAimSettings.HitChance = v end)
MainGroupBox:AddSlider('MaxDistanceSlider',{Text = 'Max Distance',Default = SilentAimSettings.MaxDistance,Min = 10,Max = 2000,Rounding = 0,Suffix = "studs"})
Options.MaxDistanceSlider:OnChanged(function(v) SilentAimSettings.MaxDistance = v end)

local VisualsGroupBox = Tabs.Main:AddRightGroupbox("Visuals")
VisualsGroupBox:AddToggle("FOVVisibleToggle",{Text = "Show FOV",Default = SilentAimSettings.FOVVisible}):AddColorPicker("FOVColorPicker",{Default = SilentAimSettings.FOVColor,Title = "FOV Color"})
Toggles.FOVVisibleToggle:OnChanged(function(v) SilentAimSettings.FOVVisible = v end)
Options.FOVColorPicker:OnChanged(function(v) SilentAimSettings.FOVColor = v end)
VisualsGroupBox:AddDropdown("FOVShapeDropdown",{Text = "FOV Style",Default = SilentAimSettings.FOVShape,Values = {"Circle", "Triangle", "Pentagram"}})
Options.FOVShapeDropdown:OnChanged(function(v) SilentAimSettings.FOVShape = v end)
VisualsGroupBox:AddSlider("FOVRadiusSlider",{Text = "FOV Radius",Min = 10,Max = 1000,Default = SilentAimSettings.FOVRadius,Rounding = 0})
Options.FOVRadiusSlider:OnChanged(function(v) SilentAimSettings.FOVRadius = v end)
VisualsGroupBox:AddToggle("FixedFOVToggle",{Text = "Fixed FOV (for Mobile)",Default = SilentAimSettings.FixedFOV})
Toggles.FixedFOVToggle:OnChanged(function(v) SilentAimSettings.FixedFOV = v end)

VisualsGroupBox:AddToggle("ShowTargetToggle",{Text = "Show Target Indicator",Default = SilentAimSettings.ShowSilentAimTarget}):AddColorPicker("TargetIndicatorColorPicker",{Default = SilentAimSettings.TargetIndicatorColor,Title = "Target Indicator Color"})
Toggles.ShowTargetToggle:OnChanged(function(v) SilentAimSettings.ShowSilentAimTarget = v end)
Options.TargetIndicatorColorPicker:OnChanged(function(v) SilentAimSettings.TargetIndicatorColor = v end)
VisualsGroupBox:AddDropdown("TargetIndicatorShapeDropdown",{Text = "Indicator Style",Default = SilentAimSettings.TargetIndicatorShape,Values = {"Circle", "Triangle", "Pentagram"}})
Options.TargetIndicatorShapeDropdown:OnChanged(function(v) SilentAimSettings.TargetIndicatorShape = v end)
VisualsGroupBox:AddSlider("TargetIndicatorRadiusSlider",{Text = "Indicator Size",Min = 5,Max = 50,Default = SilentAimSettings.TargetIndicatorRadius,Rounding = 0})
Options.TargetIndicatorRadiusSlider:OnChanged(function(v) SilentAimSettings.TargetIndicatorRadius = v end)

VisualsGroupBox:AddToggle("ShowTracerToggle",{Text = "Show Target Tracer",Default = SilentAimSettings.ShowTracer}):AddColorPicker("TracerColorPicker",{Default = tracer_line.Color,Title = "Tracer Color"})
Toggles.ShowTracerToggle:OnChanged(function(v) SilentAimSettings.ShowTracer = v end)
Options.TracerColorPicker:OnChanged(function(v) tracer_line.Color = v end)
VisualsGroupBox:AddSlider('TracerYOffsetSlider',{Text = 'Tracer Y-Axis Offset',Default = SilentAimSettings.Tracer_Y_Offset,Min = -10,Max = 10,Rounding = 3,Suffix = " studs"})
Options.TracerYOffsetSlider:OnChanged(function(v) SilentAimSettings.Tracer_Y_Offset = v end)

local PredictionGroupBox = Tabs.Main:AddRightGroupbox("Prediction")
PredictionGroupBox:AddToggle("PredictionToggle",{Text = "Mouse.Hit/Target Prediction",Default = SilentAimSettings.MouseHitPrediction})
Toggles.PredictionToggle:OnChanged(function(v) SilentAimSettings.MouseHitPrediction = v end)
PredictionGroupBox:AddSlider("PredictionAmountSlider",{Text = "Prediction Amount",Min = 0,Max = 1,Default = SilentAimSettings.MouseHitPredictionAmount,Rounding = 3})
Options.PredictionAmountSlider:OnChanged(function(v) SilentAimSettings.MouseHitPredictionAmount, PredictionAmount = v, v end)

resume(create(function()
    RenderStepped:Connect(function()
        local isEnabled = Toggles.EnabledToggle.Value
        currentTargetPart = isEnabled and getClosestPlayer() or nil
        
        ClearDrawingObjects(TargetIndicatorObjects)
        distance_text.Visible = false
        if Toggles.ShowTargetToggle.Value and isEnabled and currentTargetPart then
            local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, currentTargetPart.Position)
            if IsOnScreen then
                local indicatorColor = SilentAimSettings.TargetIndicatorColor
                local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                local targetPlayer = Players:GetPlayerFromCharacter(currentTargetPart.Parent)
                if targetPlayer and IsPlayerVisible(targetPlayer) then
                    indicatorColor = Color3.fromRGB(0, 255, 0)
                    indicatorRadius = indicatorRadius * 0.7
                end
                
                DrawShape(TargetIndicatorObjects, Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y), indicatorRadius, SilentAimSettings.TargetIndicatorShape, indicatorColor, 2)
                
                local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if localRoot then
                    distance_text.Visible = true
                    local distance = (localRoot.Position - currentTargetPart.Position).Magnitude
                    distance_text.Text = string.format("[%dm]", math.floor(distance))
                    distance_text.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y - SilentAimSettings.TargetIndicatorRadius - 8)
                end
            end
        end

        tracer_line.Visible = false
        if Toggles.ShowTracerToggle.Value and isEnabled and currentTargetPart then
            local targetCharacter = currentTargetPart.Parent
            local targetHead = targetCharacter and targetCharacter:FindFirstChild("Head")
            local tracerTargetPosition = (targetHead and targetHead.Position) or currentTargetPart.Position
            local finalTracerPosition = tracerTargetPosition - Vector3.new(0, SilentAimSettings.Tracer_Y_Offset, 0)
            local targetScreenPos, IsOnScreen = getPositionOnScreen(finalTracerPosition)
            if IsOnScreen then
                tracer_line.Visible = true
                tracer_line.From = Camera.ViewportSize / 2
                tracer_line.To = targetScreenPos
                tracer_line.Color = Options.TracerColorPicker.Value
            end
        end

        ClearDrawingObjects(FOVShapeObjects)
        if SilentAimSettings.FOVVisible and isEnabled then
            local fovCenter = SilentAimSettings.FixedFOV and Camera.ViewportSize / 2 or getMousePosition()
            DrawShape(FOVShapeObjects, fovCenter, SilentAimSettings.FOVRadius, SilentAimSettings.FOVShape, SilentAimSettings.FOVColor, 1)
        end
    end)
end))

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method, Arguments, self = getnamecallmethod(), {...}, ...[1]
    if SilentAimSettings.Enabled and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) then
        local currentMethod = SilentAimSettings.SilentAimMethod
        if currentTargetPart then
            if Method == "FindPartOnRayWithIgnoreList" and currentMethod == Method then
                if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithIgnoreList) then
                    local A_Ray = Arguments[2]
                    Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, currentTargetPart.Position))
                    return oldNamecall(unpack(Arguments))
                end
            elseif Method == "FindPartOnRayWithWhitelist" and currentMethod == Method then
                if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithWhitelist) then
                    local A_Ray = Arguments[2]
                    Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, currentTargetPart.Position))
                    return oldNamecall(unpack(Arguments))
                end
            elseif (Method == "FindPartOnRay" or Method == "findPartOnRay") and currentMethod:lower() == Method:lower() then
                if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRay) then
                    local A_Ray = Arguments[2]
                    Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, currentTargetPart.Position))
                    return oldNamecall(unpack(Arguments))
                end
            elseif Method == "Raycast" and currentMethod == Method then
                if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                    Arguments[3] = getDirection(Arguments[2], currentTargetPart.Position)
                    return oldNamecall(unpack(Arguments))
                end
            elseif (Method == "ScreenPointToRay" or Method == "ViewportPointToRay") and currentMethod == Method and self == Camera then
                return Ray.new(Camera.CFrame.Position, (currentTargetPart.Position - Camera.CFrame.Position).Unit)
            end
        end
    end
    return oldNamecall(...)
end))

local oldIndex
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    if self == Mouse and not checkcaller() and SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Mouse.Hit/Target" and currentTargetPart then
        if Index == "Target" or Index == "target" then return currentTargetPart end
        if Index == "Hit" or Index == "hit" then return (SilentAimSettings.MouseHitPrediction and (currentTargetPart.CFrame + (currentTargetPart.Velocity * currentTargetPart.Velocity.magnitude * SilentAimSettings.MouseHitPredictionAmount))) or currentTargetPart.CFrame end
        if Index == "X" or Index == "x" then return self.X end
        if Index == "Y" or Index == "y" then return self.Y end
        if Index == "UnitRay" then return Ray.new(self.Origin, (self.Hit.p - self.Origin.p).Unit) end
    end
    return oldIndex(self, Index)
end))

local oldRayNew = hookfunction(Ray.new, newcclosure(function(origin, direction)
    if SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Ray" and currentTargetPart and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) then
        return oldRayNew(origin, getDirection(origin, currentTargetPart.Position))
    end
    return oldRayNew(origin, direction)
end))

Library:OnUnload(function()
    ClearDrawingObjects(FOVShapeObjects)
    ClearDrawingObjects(TargetIndicatorObjects)
    if distance_text and distance_text.Remove then distance_text:Remove() end
    if tracer_line and tracer_line.Remove then tracer_line:Remove() end
end)

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder("UniversalSilentAim/Configs")
SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])
SaveManager:LoadAutoloadConfig()
