if not game:IsLoaded() then
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

local SilentAimSettings = {
    Enabled = false,
    ClassName = "Universal Silent Aim - Averiias, Stefanuk12, xaxa",
    ToggleKey = "RightAlt",
    TeamCheck = false,
    VisibleCheck = false,
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    FOVVisible = false,
    ShowSilentAimTarget = false,
    ShowTracer = false,
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100,
    FixedFOV = false,
    TargetIndicatorRadius = 20,
    MaxDistance = 500,
    Tracer_Y_Offset = 0
}

getgenv().SilentAimSettings = SilentAimSettings
local MainFileName = "UniversalSilentAim"
local SelectedFile, FileToSave = "", ""

local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetChildren = game.GetChildren
local GetPlayers = Players.GetPlayers
local WorldToScreen = Camera.WorldToScreenPoint
local WorldToViewportPoint = Camera.WorldToViewportPoint
local GetPartsObscuringTarget = Camera.GetPartsObscuringTarget
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GuiInset = GuiService.GetGuiInset
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume
local create = coroutine.create

local ValidTargetParts = {"Head", "HumanoidRootPart"}
local PredictionAmount = 0.165

local target_indicator = Drawing.new("Circle")
target_indicator.Visible = false
target_indicator.ZIndex = 1000
target_indicator.Color = Color3.fromRGB(255, 0, 0)
target_indicator.Thickness = 2
target_indicator.Radius = 20
target_indicator.Filled = false

local fov_circle = Drawing.new("Circle")
fov_circle.Thickness = 1
fov_circle.NumSides = 100
fov_circle.Radius = 180
fov_circle.Filled = false
fov_circle.Visible = false
fov_circle.ZIndex = 999
fov_circle.Transparency = 1
fov_circle.Color = Color3.fromRGB(54, 57, 241)

local tracer_line = Drawing.new("Line")
tracer_line.Visible = false
tracer_line.ZIndex = 998
tracer_line.Color = Color3.fromRGB(255, 255, 0)
tracer_line.Thickness = 1
tracer_line.Transparency = 1

local ExpectedArguments = {
    FindPartOnRayWithIgnoreList = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean", "boolean"} },
    FindPartOnRayWithWhitelist = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean"} },
    FindPartOnRay = { ArgCountRequired = 2, Args = {"Instance", "Ray", "Instance", "boolean", "boolean"} },
    Raycast = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} }
}

function CalculateChance(Percentage)
    Percentage = math.floor(Percentage)
    local chance = math.floor(Random.new().NextNumber(Random.new(), 0, 1) * 100) / 100
    return chance <= Percentage / 100
end

do
    if not isfolder(MainFileName) then
        makefolder(MainFileName);
    end

    if not isfolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) then
        makefolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId)))
    end
end

local function getPositionOnScreen(Vector)
    local Vec3, OnScreen = WorldToScreen(Camera, Vector)
    return Vector2.new(Vec3.X, Vec3.Y), OnScreen
end

local function ValidateArguments(Args, RayMethod)
    local Matches = 0
    if #Args < RayMethod.ArgCountRequired then return false end
    for Pos, Argument in next, Args do
        if typeof(Argument) == RayMethod.Args[Pos] then Matches = Matches + 1 end
    end
    return Matches >= RayMethod.ArgCountRequired
end

local function getDirection(Origin, Position)
    return (Position - Origin).Unit * 1000
end

local function getMousePosition()
    return GetMouseLocation(UserInputService)
end

local function IsPlayerVisible(Player)
    local PlayerCharacter = Player.Character
    local LocalPlayerCharacter = LocalPlayer.Character
    if not (PlayerCharacter and LocalPlayerCharacter) then return end
    local targetPartName = SilentAimSettings.TargetPart
    if targetPartName == "Random" then targetPartName = "HumanoidRootPart" end
    local PlayerRoot = FindFirstChild(PlayerCharacter, targetPartName) or FindFirstChild(PlayerCharacter, "HumanoidRootPart")
    if not PlayerRoot then return end
    local CastPoints, IgnoreList = {PlayerRoot.Position, LocalPlayerCharacter, PlayerCharacter}, {LocalPlayerCharacter, PlayerCharacter}
    local ObscuringObjects = #GetPartsObscuringTarget(Camera, CastPoints, IgnoreList)
    return ((ObscuringObjects == 0 and true) or (ObscuringObjects > 0 and false))
end

local function getClosestPlayer()
    local Closest = nil
    local DistanceToAimPoint = SilentAimSettings.FOVRadius
    local AimPoint
    local LocalPlayerCharacter = LocalPlayer.Character
    if not LocalPlayerCharacter then return nil end
    local localRoot = FindFirstChild(LocalPlayerCharacter, "HumanoidRootPart")
    if not localRoot then return nil end

    if SilentAimSettings.FixedFOV then
        AimPoint = Camera.ViewportSize / 2
    else
        AimPoint = getMousePosition()
    end

    for _, Player in next, GetPlayers(Players) do
        if Player ~= LocalPlayer and not (SilentAimSettings.TeamCheck and Player.Team == LocalPlayer.Team) then
            local Character = Player.Character
            local targetRoot = Character and FindFirstChild(Character, "HumanoidRootPart")

            if Character and targetRoot and not (SilentAimSettings.VisibleCheck and not IsPlayerVisible(Player)) then
                
                local distance = (localRoot.Position - targetRoot.Position).Magnitude
                if distance <= SilentAimSettings.MaxDistance then

                    local Humanoid = FindFirstChild(Character, "Humanoid")
                    if Humanoid and Humanoid.Health > 0 then
                        local TargetPartName = SilentAimSettings.TargetPart
                        local PartToAim = FindFirstChild(Character, TargetPartName)
                        if TargetPartName == "Random" then
                            PartToAim = Character[ValidTargetParts[math.random(1, #ValidTargetParts)]]
                        end
                        if PartToAim then
                            local ScreenPosition, OnScreen = getPositionOnScreen(PartToAim.Position)
                            if OnScreen then
                                local FovDistance = (AimPoint - ScreenPosition).Magnitude
                                if FovDistance <= DistanceToAimPoint then
                                    Closest = PartToAim
                                    DistanceToAimPoint = FovDistance
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return Closest
end

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()

local Options = Library.Options
local Toggles = Library.Toggles

local Window = Library:CreateWindow({
    Title = "Universal Silent Aim [UI Replaced]",
    Footer = "version: raw_merge_indicator_fix",
    Center = true,
    AutoShow = true
})

local Tabs = {
    Main = Window:AddTab("Main", "user"),
    ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

local MainGroupBox = Tabs.Main:AddLeftGroupbox("Main Settings", "boxes")

MainGroupBox:AddToggle("EnabledToggle", { Text = "Enabled", Default = SilentAimSettings.Enabled, }):AddKeyPicker("EnabledKeybind", { Default = SilentAimSettings.ToggleKey, SyncToggleState = true, Mode = "Toggle" })
Toggles.EnabledToggle:OnChanged(function(Value) SilentAimSettings.Enabled = Value end)

MainGroupBox:AddToggle("TeamCheckToggle", { Text = "Team Check", Default = SilentAimSettings.TeamCheck, })
Toggles.TeamCheckToggle:OnChanged(function(Value) SilentAimSettings.TeamCheck = Value end)

MainGroupBox:AddToggle("VisibleCheckToggle", { Text = "Visible Check", Default = SilentAimSettings.VisibleCheck, })
Toggles.VisibleCheckToggle:OnChanged(function(Value) SilentAimSettings.VisibleCheck = Value end)

MainGroupBox:AddDropdown("TargetPartDropdown", { Values = {"Head", "HumanoidRootPart", "Random"}, Default = SilentAimSettings.TargetPart, Text = "Target Part", })
Options.TargetPartDropdown:OnChanged(function(Value) SilentAimSettings.TargetPart = Value end)

MainGroupBox:AddDropdown("MethodDropdown", { Text = "Silent Aim Method", Default = SilentAimSettings.SilentAimMethod, Values = { "Raycast","FindPartOnRay", "FindPartOnRayWithWhitelist", "FindPartOnRayWithIgnoreList", "ScreenPointToRay", "ViewportPointToRay", "Ray", "Mouse.Hit/Target" } })
Options.MethodDropdown:OnChanged(function(Value) SilentAimSettings.SilentAimMethod = Value end)

MainGroupBox:AddSlider('HitChanceSlider', { Text = 'Hit chance', Default = SilentAimSettings.HitChance, Min = 0, Max = 100, Rounding = 1, Suffix = "%" })
Options.HitChanceSlider:OnChanged(function(Value) SilentAimSettings.HitChance = Value end)

MainGroupBox:AddSlider('MaxDistanceSlider', { Text = 'Max Distance', Default = SilentAimSettings.MaxDistance, Min = 10, Max = 2000, Rounding = 0, Suffix = "studs" })
Options.MaxDistanceSlider:OnChanged(function(Value) SilentAimSettings.MaxDistance = Value end)

local VisualsGroupBox = Tabs.Main:AddRightGroupbox("Visuals")

VisualsGroupBox:AddToggle("FOVVisibleToggle", { Text = "Show FOV Circle", Default = SilentAimSettings.FOVVisible, }):AddColorPicker("FOVColorPicker", { Default = fov_circle.Color, Title = "FOV Circle Color" })
Toggles.FOVVisibleToggle:OnChanged(function(Value) fov_circle.Visible = Value; SilentAimSettings.FOVVisible = Value end)
Options.FOVColorPicker:OnChanged(function(Value) fov_circle.Color = Value end)

VisualsGroupBox:AddSlider("FOVRadiusSlider", { Text = "FOV Circle Radius", Min = 10, Max = 1000, Default = SilentAimSettings.FOVRadius, Rounding = 0 })
Options.FOVRadiusSlider:OnChanged(function(Value) fov_circle.Radius = Value; SilentAimSettings.FOVRadius = Value end)

VisualsGroupBox:AddToggle("FixedFOVToggle", { Text = "Fixed FOV (for Mobile)", Default = SilentAimSettings.FixedFOV, })
Toggles.FixedFOVToggle:OnChanged(function(Value) SilentAimSettings.FixedFOV = Value end)

VisualsGroupBox:AddToggle("ShowTargetToggle", { Text = "Show Target Indicator", Default = SilentAimSettings.ShowSilentAimTarget, }):AddColorPicker("TargetIndicatorColorPicker", { Default = target_indicator.Color, Title = "Target Indicator Color" })
Toggles.ShowTargetToggle:OnChanged(function(Value) SilentAimSettings.ShowSilentAimTarget = Value end)
Options.TargetIndicatorColorPicker:OnChanged(function(Value) target_indicator.Color = Value end)

VisualsGroupBox:AddSlider("TargetIndicatorRadiusSlider", { Text = "Indicator Size", Min = 5, Max = 50, Default = SilentAimSettings.TargetIndicatorRadius, Rounding = 0})
Options.TargetIndicatorRadiusSlider:OnChanged(function(Value) SilentAimSettings.TargetIndicatorRadius = Value end)

VisualsGroupBox:AddToggle("ShowTracerToggle", { Text = "Show Target Tracer", Default = SilentAimSettings.ShowTracer, }):AddColorPicker("TracerColorPicker", { Default = tracer_line.Color, Title = "Tracer Color" })
Toggles.ShowTracerToggle:OnChanged(function(Value) SilentAimSettings.ShowTracer = Value end)
Options.TracerColorPicker:OnChanged(function(Value) tracer_line.Color = Value end)

VisualsGroupBox:AddSlider('TracerYOffsetSlider', {
    Text = 'Tracer Y-Axis Offset',
    Default = SilentAimSettings.Tracer_Y_Offset,
    Min = -10,
    Max = 10,
    Rounding = 3,
    Suffix = " studs"
})
Options.TracerYOffsetSlider:OnChanged(function(Value) SilentAimSettings.Tracer_Y_Offset = Value end)

local PredictionGroupBox = Tabs.Main:AddRightGroupbox("Prediction")

PredictionGroupBox:AddToggle("PredictionToggle", { Text = "Mouse.Hit/Target Prediction", Default = SilentAimSettings.MouseHitPrediction, })
Toggles.PredictionToggle:OnChanged(function(Value) SilentAimSettings.MouseHitPrediction = Value end)

PredictionGroupBox:AddSlider("PredictionAmountSlider", { Text = "Prediction Amount", Min = 0, Max = 1, Default = SilentAimSettings.MouseHitPredictionAmount, Rounding = 3 })
Options.PredictionAmountSlider:OnChanged(function(Value) SilentAimSettings.MouseHitPredictionAmount = Value; PredictionAmount = Value end)

resume(create(function()
    RenderStepped:Connect(function()
        local isEnabled = Toggles.EnabledToggle.Value
        local closestPlayerPart = nil

        if isEnabled then
            closestPlayerPart = getClosestPlayer()
        end

        if Toggles.ShowTargetToggle.Value and isEnabled and closestPlayerPart then
            local RootToViewportPoint, IsOnScreen = WorldToViewportPoint(Camera, closestPlayerPart.Position)
            target_indicator.Visible = IsOnScreen
            if IsOnScreen then
                target_indicator.Position = Vector2.new(RootToViewportPoint.X, RootToViewportPoint.Y)
                target_indicator.Radius = SilentAimSettings.TargetIndicatorRadius
            end
        else
            target_indicator.Visible = false
        end

        if Toggles.ShowTracerToggle.Value and isEnabled and closestPlayerPart then
            local targetCharacter = closestPlayerPart.Parent
            local targetHead = targetCharacter and targetCharacter:FindFirstChild("Head")
            local tracerTargetPosition = (targetHead and targetHead.Position) or closestPlayerPart.Position
            
            local y_offset = SilentAimSettings.Tracer_Y_Offset
            local finalTracerPosition = tracerTargetPosition - Vector3.new(0, y_offset, 0)
            
            local targetScreenPos, IsOnScreen = getPositionOnScreen(finalTracerPosition)

            tracer_line.Visible = IsOnScreen
            if IsOnScreen then
                tracer_line.From = Camera.ViewportSize / 2
                tracer_line.To = targetScreenPos
                tracer_line.Color = Options.TracerColorPicker.Value
            end
        else
            tracer_line.Visible = false
        end
        
        fov_circle.Visible = Toggles.FOVVisibleToggle.Value
        if fov_circle.Visible then
            fov_circle.Color = Options.FOVColorPicker.Value
            fov_circle.Radius = Options.FOVRadiusSlider.Value
            if Toggles.FixedFOVToggle.Value then
                fov_circle.Position = Camera.ViewportSize / 2
            else
                fov_circle.Position = getMousePosition()
            end
        end
    end)
end))

local oldNamecall
oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...)
    local Method = getnamecallmethod()
    local Arguments = {...}
    local self = Arguments[1]

    if SilentAimSettings.Enabled and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) then
        local currentMethod = SilentAimSettings.SilentAimMethod
        local HitPart = getClosestPlayer()
        if HitPart then
            if Method == "FindPartOnRayWithIgnoreList" and currentMethod == Method then
                if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithIgnoreList) then
                    local A_Ray = Arguments[2]
                    Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, HitPart.Position))
                    return oldNamecall(unpack(Arguments))
                end
            elseif Method == "FindPartOnRayWithWhitelist" and currentMethod == Method then
                if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithWhitelist) then
                    local A_Ray = Arguments[2]
                    Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, HitPart.Position))
                    return oldNamecall(unpack(Arguments))
                end
            elseif (Method == "FindPartOnRay" or Method == "findPartOnRay") and currentMethod:lower() == Method:lower() then
                if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRay) then
                    local A_Ray = Arguments[2]
                    Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, HitPart.Position))
                    return oldNamecall(unpack(Arguments))
                end
            elseif Method == "Raycast" and currentMethod == Method then
                if ValidateArguments(Arguments, ExpectedArguments.Raycast) then
                    Arguments[3] = getDirection(Arguments[2], HitPart.Position)
                    return oldNamecall(unpack(Arguments))
                end
            elseif (Method == "ScreenPointToRay" or Method == "ViewportPointToRay") and currentMethod == Method and self == Camera then
                local origin = Camera.CFrame.Position
                local direction = (HitPart.Position - origin).Unit
                return Ray.new(origin, direction)
            end
        end
    end
    return oldNamecall(...)
end))

local oldIndex
local oldRayNew
oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index)
    if self == Mouse and not checkcaller() and SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Mouse.Hit/Target" then
        local HitPart = getClosestPlayer()
        if HitPart then
            if Index == "Target" or Index == "target" then
                return HitPart
            elseif Index == "Hit" or Index == "hit" then
                return (SilentAimSettings.MouseHitPrediction and (HitPart.CFrame + (HitPart.Velocity * SilentAimSettings.MouseHitPredictionAmount))) or HitPart.CFrame
            elseif Index == "X" or Index == "x" then
                return self.X
            elseif Index == "Y" or Index == "y" then
                return self.Y
            elseif Index == "UnitRay" then
                return Ray.new(self.Origin, (self.Hit - self.Origin).Unit)
            end
        end
    end
    return oldIndex(self, Index)
end))

oldRayNew = hookfunction(Ray.new, newcclosure(function(origin, direction)
    if SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Ray" and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) then
        local HitPart = getClosestPlayer()
        if HitPart then
            local newDirectionVector = getDirection(origin, HitPart.Position)
            return oldRayNew(origin, newDirectionVector)
        end
    end
    return oldRayNew(origin, direction)
end))

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ "MenuKeybind" })
SaveManager:SetFolder("UniversalSilentAim/Configs")

SaveManager:BuildConfigSection(Tabs["UI Settings"])
ThemeManager:ApplyToTab(Tabs["UI Settings"])

SaveManager:LoadAutoloadConfig()
