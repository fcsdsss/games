if not game:IsLoaded() then
    game.Loaded:Wait()
end

if not syn or not protectgui then
    getgenv().protectgui = function() end
end

local SilentAimSettings = {
    Enabled = false,
    ClassName = "Universal Silent Aim - Final Whitelist",
    ToggleKey = "RightAlt",
    TeamCheck = false,
    VisibleCheck = false,
    VisiblePartOverride = false,
    TargetPart = "HumanoidRootPart",
    SilentAimMethod = "Raycast",
    FOVRadius = 130,
    FOVVisible = true,
    ShowSilentAimTarget = false,
    ShowTracer = false,
    MouseHitPrediction = false,
    MouseHitPredictionAmount = 0.165,
    HitChance = 100,
    FixedFOV = true,
    TargetIndicatorRadius = 20,
    IndicatorRotationEnabled = false,
    IndicatorRotationSpeed = 1,
    IndicatorRainbowEnabled = false,
    IndicatorRainbowSpeed = 1,
    MaxDistance = 500,
    Tracer_Y_Offset = 0,
    OptimizeForDistance = false,
    TargetInfoStyle = "面板",
    LockPanelPosition = true,
    RandomDamageColor = false,
    ShowTargetName = false,
    ShowTargetHealth = false,
    ShowTargetDistance = false,
    TargetMode = "玩家"
}

getgenv().SilentAimSettings = SilentAimSettings
local MainFileName = "UniversalSilentAim"

local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local UserInputService = game:GetService("UserInputService")
local HttpService = game:GetService("HttpService")
local TweenService = game:GetService("TweenService")

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local GetPlayers = Players.GetPlayers
local WorldToViewportPoint = Camera.WorldToViewportPoint
local FindFirstChild = game.FindFirstChild
local RenderStepped = RunService.RenderStepped
local GetMouseLocation = UserInputService.GetMouseLocation

local resume = coroutine.resume
local create = coroutine.create

local ValidTargetParts = {"Head", "HumanoidRootPart"}
local PrioritizedVisibleParts = {"Head", "UpperTorso", "HumanoidRootPart", "LowerTorso", "RightUpperLeg", "LeftUpperLeg"}
local PredictionAmount = 0.165

local currentTargetPart = nil
local currentRotationAngle = 0
local currentIndicatorHue = 0
local npcList = {}
local targetHealthCache = {}

local target_indicator_circle = Drawing.new("Circle")
target_indicator_circle.Visible = false; target_indicator_circle.ZIndex = 1000; target_indicator_circle.Thickness = 2; target_indicator_circle.Filled = false
local target_indicator_lines = {}
for i = 1, 5 do local line = Drawing.new("Line"); line.Visible = false; line.ZIndex = 1000; line.Thickness = 2; table.insert(target_indicator_lines, line) end
local tracer_line = Drawing.new("Line")
tracer_line.Visible = false; tracer_line.ZIndex = 998; tracer_line.Color = Color3.fromRGB(255, 255, 0); tracer_line.Thickness = 1; tracer_line.Transparency = 1

local overhead_info_texts = { Name = Drawing.new("Text"), Health = Drawing.new("Text"), Distance = Drawing.new("Text") }
for _, text in pairs(overhead_info_texts) do text.Visible = false; text.ZIndex = 1001; text.Font = Drawing.Fonts.Plex; text.Size = 14; text.Color = Color3.fromRGB(255, 255, 255); text.Center = true; text.Outline = true end

local panel_info_bg = Drawing.new("Square")
panel_info_bg.Visible = false; panel_info_bg.ZIndex = 1002; panel_info_bg.Color = Color3.fromRGB(0, 0, 0); panel_info_bg.Thickness = 0; panel_info_bg.Filled = true; panel_info_bg.Transparency = 0.5
local panel_info_texts = { Name = Drawing.new("Text"), Health = Drawing.new("Text"), Distance = Drawing.new("Text") }
for _, text in pairs(panel_info_texts) do text.Visible = false; text.ZIndex = 1003; text.Font = Drawing.Fonts.Plex; text.Size = 14; text.Color = Color3.fromRGB(255, 255, 255); text.Center = false; text.Outline = true end

local FOVCircleGui = Instance.new("ScreenGui", LocalPlayer:WaitForChild("PlayerGui"))
FOVCircleGui.Name = "FOVCircleGui"; FOVCircleGui.ResetOnSpawn = false; FOVCircleGui.IgnoreGuiInset = true; FOVCircleGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
local FOVCircleFrame = Instance.new("Frame", FOVCircleGui)
FOVCircleFrame.Name = "FOVCircleFrame"; FOVCircleFrame.AnchorPoint = Vector2.new(0.5, 0.5); FOVCircleFrame.Position = UDim2.fromScale(0.5, 0.5); FOVCircleFrame.BackgroundTransparency = 1
local FOVStroke = Instance.new("UIStroke", FOVCircleFrame)
FOVStroke.Name = "FOVStroke"; FOVStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border; FOVStroke.Thickness = 1; FOVStroke.Transparency = 0.5
local FOVCorner = Instance.new("UICorner", FOVCircleFrame)
FOVCorner.Name = "FOVCorner"; FOVCorner.CornerRadius = UDim.new(1, 0)

local DraggableInfoPanel = Instance.new("Frame", FOVCircleGui)
DraggableInfoPanel.Name = "DraggableInfoPanel"; DraggableInfoPanel.Position = UDim2.fromOffset(10, 100); DraggableInfoPanel.BackgroundColor3 = Color3.fromRGB(0, 0, 0); DraggableInfoPanel.BackgroundTransparency = 0.5; DraggableInfoPanel.BorderSizePixel = 0; DraggableInfoPanel.Visible = false; DraggableInfoPanel.Active = true
DraggableInfoPanel.Size = UDim2.fromOffset(120, 0); DraggableInfoPanel.AutomaticSize = Enum.AutomaticSize.Y
DraggableInfoPanel.Draggable = not SilentAimSettings.LockPanelPosition
local DraggableLayout = Instance.new("UIListLayout", DraggableInfoPanel); DraggableLayout.SortOrder = Enum.SortOrder.LayoutOrder
local DraggablePadding = Instance.new("UIPadding", DraggableInfoPanel)
DraggablePadding.PaddingTop = UDim.new(0, 5); DraggablePadding.PaddingBottom = UDim.new(0, 5); DraggablePadding.PaddingLeft = UDim.new(0, 5); DraggablePadding.PaddingRight = UDim.new(0, 5)

local function CreatePanelTextLabel(name)
    local label = Instance.new("TextLabel", DraggableInfoPanel)
    label.Name = name; label.Size = UDim2.new(1, 0, 0, 14); label.Text = ""; label.Font = Enum.Font.Plex; label.TextSize = 14; label.TextColor3 = Color3.fromRGB(255, 255, 255); label.TextXAlignment = Enum.TextXAlignment.Left; label.BackgroundTransparency = 1; label.Visible = false; label.LayoutOrder = 1
    local stroke = Instance.new("UIStroke", label); stroke.Color = Color3.fromRGB(0, 0, 0); stroke.Thickness = 1; stroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    return label
end

local DraggableInfoName = CreatePanelTextLabel("Name")
local DraggableInfoHealth = CreatePanelTextLabel("Health")
local DraggableInfoDistance = CreatePanelTextLabel("Distance")

local ExpectedArguments = { FindPartOnRayWithIgnoreList = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean", "boolean"} }, FindPartOnRayWithWhitelist = { ArgCountRequired = 3, Args = {"Instance", "Ray", "table", "boolean"} }, FindPartOnRay = { ArgCountRequired = 2, Args = {"Instance", "Ray", "Instance", "boolean", "boolean"} }, Raycast = { ArgCountRequired = 3, Args = {"Instance", "Vector3", "Vector3", "RaycastParams"} } }
function CalculateChance(Percentage) return math.random() <= math.floor(Percentage) / 100 end
do if not isfolder(MainFileName) then makefolder(MainFileName) end; if not isfolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) then makefolder(string.format("%s/%s", MainFileName, tostring(game.PlaceId))) end end
function getPositionOnScreen(Vector) local Vec3, OnScreen = WorldToViewportPoint(Camera, Vector); return Vector2.new(Vec3.X, Vec3.Y), OnScreen end
function ValidateArguments(Args, RayMethod) local Matches = 0; if #Args < RayMethod.ArgCountRequired then return false end; for Pos, Argument in next, Args do if typeof(Argument) == RayMethod.Args[Pos] then Matches = Matches + 1 end end; return Matches >= RayMethod.ArgCountRequired end
function getDirection(Origin, Position) return (Position - Origin).Unit * 1000 end
function isNPC(obj) return obj:IsA("Model") and obj:FindFirstChild("Humanoid") and obj.Humanoid.Health > 0 and obj:FindFirstChild("HumanoidRootPart") and not Players:GetPlayerFromCharacter(obj) end
function updateNPCs() npcList = {}; for _, v in ipairs(workspace:GetChildren()) do if isNPC(v) then table.insert(npcList, v) end end end
function IsPartVisible(part, character) if not part or not character then return false end; local localCharacter = LocalPlayer.Character; if not localCharacter then return false end; local cameraPosition = Camera.CFrame.Position; local direction = part.Position - cameraPosition; local raycastParams = RaycastParams.new(); raycastParams.FilterType = Enum.RaycastFilterType.Exclude; raycastParams.FilterDescendantsInstances = {localCharacter, character}; local raycastResult = workspace:Raycast(cameraPosition, direction.Unit * (direction.Magnitude + 0.1), raycastParams); return not raycastResult or raycastResult.Instance:IsDescendantOf(character) end

function getVisiblePart(character)
    if not character then return nil end
    for _, partName in ipairs(PrioritizedVisibleParts) do
        local part = character:FindFirstChild(partName)
        if part and IsPartVisible(part, character) then
            return part
        end
    end
    return nil
end

function getTargetPart(character)
    if not character then return nil end
    local TargetPartName = SilentAimSettings.TargetPart
    if TargetPartName == "Random" then TargetPartName = ValidTargetParts[math.random(1, #ValidTargetParts)] end
    return FindFirstChild(character, TargetPartName)
end

function getAllTargetsInFov(targetList, localRoot)
    local AimPoint = SilentAimSettings.FixedFOV and (Camera.ViewportSize / 2) or GetMouseLocation(UserInputService)
    local candidates = {}
    
    for _, obj in ipairs(targetList) do
        local Character = (obj:IsA("Player") and obj.Character) or obj
        local targetName = (obj:IsA("Player") and obj.Name) or (Character and Character.Name)
        if Character and targetName and Character:FindFirstChild("HumanoidRootPart") and Character:FindFirstChildOfClass("Humanoid") and Character.Humanoid.Health > 0 then
            if not (SilentAimSettings.VisibleCheck and not IsPartVisible(Character.HumanoidRootPart, Character)) then
                local physicalDist = (localRoot.Position - Character.HumanoidRootPart.Position).Magnitude
                if physicalDist <= SilentAimSettings.MaxDistance then
                    local tempPart = Character.HumanoidRootPart
                    local ScreenPosition, OnScreen = getPositionOnScreen(tempPart.Position)
                    if OnScreen then
                        local fovDist = (AimPoint - ScreenPosition).Magnitude
                        if fovDist <= SilentAimSettings.FOVRadius then
                            table.insert(candidates, {character = Character, name = targetName, fov = fovDist, dist = physicalDist})
                        end
                    end
                end
            end
        end
    end
    return candidates
end

function getBestTarget(candidates) if not candidates or #candidates == 0 then return nil end; table.sort(candidates, function(a, b) return SilentAimSettings.OptimizeForDistance and a.dist < b.dist or a.fov < b.fov end); return candidates[1].character end
function table_equal(t1, t2) if #t1 ~= #t2 then return false end; for i = 1, #t1 do if t1[i] ~= t2[i] then return false end end; return true end
function getPolygonPoints(center, radius, sides) local points = {}; local rotationOffset = SilentAimSettings.IndicatorRotationEnabled and currentRotationAngle or 0; for i = 1, sides do local angle = (i - 1) * (2 * math.pi / sides) - (math.pi / 2) + rotationOffset; table.insert(points, Vector2.new(center.X + radius * math.cos(angle), center.Y + radius * math.sin(angle))) end; return points end
function hideAllVisuals() target_indicator_circle.Visible = false; for _, line in ipairs(target_indicator_lines) do line.Visible = false end; for _, text in pairs(overhead_info_texts) do text.Visible = false end; panel_info_bg.Visible = false; for _, text in pairs(panel_info_texts) do text.Visible = false end; DraggableInfoPanel.Visible = (SilentAimSettings.TargetInfoStyle == "独立面板") end
function ShowDamageIndicator(position, damage)
    local damageLabel = Instance.new("TextLabel", FOVCircleGui); damageLabel.Text = tostring(math.floor(damage)); damageLabel.Size = UDim2.fromOffset(100, 30); damageLabel.Position = UDim2.fromOffset(position.X, position.Y); damageLabel.AnchorPoint = Vector2.new(0.5, 0.5); damageLabel.BackgroundTransparency = 1; damageLabel.Font = Enum.Font.SourceSansBold; damageLabel.TextSize = 22
    if SilentAimSettings.RandomDamageColor then damageLabel.TextColor3 = Color3.fromHSV(math.random(), 0.9, 1) else damageLabel.TextColor3 = Color3.fromRGB(255, 50, 50) end
    local stroke = Instance.new("UIStroke", damageLabel); stroke.Color = Color3.fromRGB(0,0,0); stroke.Thickness = 1.5;
    local tweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out); local goal = { Position = UDim2.fromOffset(position.X, position.Y - 50), TextTransparency = 1, StrokeTransparency = 1 }; local tween = TweenService:Create(damageLabel, tweenInfo, goal); tween:Play(); tween.Completed:Connect(function() damageLabel:Destroy() end)
end

local repo = "https://raw.githubusercontent.com/deividcomsono/Obsidian/main/"
local Library = loadstring(game:HttpGet(repo .. "Library.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "addons/ThemeManager.lua"))()
local SaveManager = loadstring(game:HttpGet(repo .. "addons/SaveManager.lua"))()
local Options = Library.Options; local Toggles = Library.Toggles
local Window = Library:CreateWindow({ Title = "Universal Silent Aim", Footer = "v3.6 (稳定版)", Center = true, AutoShow = true })
local Tabs = { Main = Window:AddTab("主页", "user"), Misc = Window:AddTab("杂项", "boxes"), ["UI Settings"] = Window:AddTab("UI设置", "settings") }

local MainGroupBox = Tabs.Main:AddLeftGroupbox("主设置", "boxes")
MainGroupBox:AddToggle("EnabledToggle", { Text = "启用", Default = SilentAimSettings.Enabled }):AddKeyPicker("EnabledKeybind", { Default = SilentAimSettings.ToggleKey, SyncToggleState = true, Mode = "Toggle" })
Toggles.EnabledToggle:OnChanged(function(Value) SilentAimSettings.Enabled = Value end)
MainGroupBox:AddDropdown("TargetSelectionDropdown", { Text = "锁定目标", Default = "无", Values = {"无"} })
MainGroupBox:AddToggle("TeamCheckToggle", { Text = "队伍检查", Default = SilentAimSettings.TeamCheck }):OnChanged(function(Value) SilentAimSettings.TeamCheck = Value end)
MainGroupBox:AddToggle("VisibleCheckToggle", { Text = "可见性检查", Default = SilentAimSettings.VisibleCheck }):OnChanged(function(Value) SilentAimSettings.VisibleCheck = Value end)
MainGroupBox:AddDropdown("TargetModeDropdown", { Text = "目标模式", Default = SilentAimSettings.TargetMode, Values = {"玩家", "NPC", "所有"} }):OnChanged(function(Value) SilentAimSettings.TargetMode = Value end)
MainGroupBox:AddDropdown("TargetPartDropdown", { Values = {"Head", "HumanoidRootPart", "Random"}, Default = SilentAimSettings.TargetPart, Text = "目标部位" }):OnChanged(function(Value) SilentAimSettings.TargetPart = Value end)
MainGroupBox:AddToggle("VisiblePartOverrideToggle", { Text = "优先攻击可见部位", Default = SilentAimSettings.VisiblePartOverride }):OnChanged(function(Value) SilentAimSettings.VisiblePartOverride = Value end)
MainGroupBox:AddSlider('HitChanceSlider', { Text = '命中率', Default = SilentAimSettings.HitChance, Min = 0, Max = 100, Rounding = 1, Suffix = "%" }):OnChanged(function(Value) SilentAimSettings.HitChance = Value end)
MainGroupBox:AddSlider('MaxDistanceSlider', { Text = '最大距离', Default = SilentAimSettings.MaxDistance, Min = 10, Max = 2000, Rounding = 0, Suffix = "studs" }):OnChanged(function(Value) SilentAimSettings.MaxDistance = Value end)

local VisualsGroupBox = Tabs.Main:AddRightGroupbox("视觉效果"); VisualsGroupBox:AddToggle("FOVVisibleToggle", { Text = "显示FOV圈", Default = SilentAimSettings.FOVVisible }):AddColorPicker("FOVColorPicker", { Default = Color3.fromRGB(54, 57, 241), Title = "FOV圈颜色" }); Toggles.FOVVisibleToggle:OnChanged(function(Value) FOVCircleGui.Enabled = Value; SilentAimSettings.FOVVisible = Value end); Options.FOVColorPicker:OnChanged(function(Value) FOVStroke.Color = Value end); VisualsGroupBox:AddSlider("FOVRadiusSlider", { Text = "FOV圈半径", Min = 10, Max = 1000, Default = SilentAimSettings.FOVRadius, Rounding = 0 }):OnChanged(function(Value) FOVCircleFrame.Size = UDim2.fromOffset(Value * 2, Value * 2); SilentAimSettings.FOVRadius = Value end); VisualsGroupBox:AddToggle("FixedFOVToggle", { Text = "固定FOV (移动端)", Default = SilentAimSettings.FixedFOV }):OnChanged(function(Value) SilentAimSettings.FixedFOV = Value end); VisualsGroupBox:AddToggle("ShowTargetToggle", { Text = "显示目标", Default = SilentAimSettings.ShowSilentAimTarget }):AddColorPicker("TargetIndicatorColorPicker", { Default = Color3.fromRGB(255,0,0), Title = "指示器颜色" }); Toggles.ShowTargetToggle:OnChanged(function(Value) SilentAimSettings.ShowSilentAimTarget = Value end); Options.TargetIndicatorColorPicker:OnChanged(function(Value) target_indicator_circle.Color = Value; for _, line in ipairs(target_indicator_lines) do line.Color = Value end end); VisualsGroupBox:AddDropdown("IndicatorStyleDropdown", { Text = "指示器样式", Values = {"Circle", "Triangle", "Pentagram"}, Default = "Circle" }); VisualsGroupBox:AddSlider("TargetIndicatorRadiusSlider", { Text = "指示器大小", Min = 5, Max = 50, Default = SilentAimSettings.TargetIndicatorRadius, Rounding = 0 }):OnChanged(function(Value) SilentAimSettings.TargetIndicatorRadius = Value end); VisualsGroupBox:AddToggle("IndicatorRotationToggle", { Text = "指示器旋转", Default = SilentAimSettings.IndicatorRotationEnabled }):OnChanged(function(Value) SilentAimSettings.IndicatorRotationEnabled = Value end); VisualsGroupBox:AddSlider("IndicatorRotationSpeedSlider", { Text = "旋转速度", Min = 0, Max = 10, Default = SilentAimSettings.IndicatorRotationSpeed, Rounding = 1, Compact = true }):OnChanged(function(Value) SilentAimSettings.IndicatorRotationSpeed = Value end); VisualsGroupBox:AddToggle("IndicatorRainbowToggle", { Text = "启用彩虹色", Default = SilentAimSettings.IndicatorRainbowEnabled }):OnChanged(function(Value) SilentAimSettings.IndicatorRainbowEnabled = Value end); VisualsGroupBox:AddSlider("IndicatorRainbowSpeedSlider", { Text = "颜色变换速度", Min = 0, Max = 10, Default = SilentAimSettings.IndicatorRainbowSpeed, Rounding = 1, Compact = true }):OnChanged(function(Value) SilentAimSettings.IndicatorRainbowSpeed = Value end); VisualsGroupBox:AddToggle("ShowTracerToggle", { Text = "显示目标追踪线", Default = SilentAimSettings.ShowTracer }):AddColorPicker("TracerColorPicker", { Default = tracer_line.Color, Title = "追踪线颜色" }); Toggles.ShowTracerToggle:OnChanged(function(Value) SilentAimSettings.ShowTracer = Value end); Options.TracerColorPicker:OnChanged(function(Value) tracer_line.Color = Value end); VisualsGroupBox:AddSlider('TracerYOffsetSlider', { Text = '追踪线Y轴偏移', Default = SilentAimSettings.Tracer_Y_Offset, Min = -10, Max = 10, Rounding = 3, Suffix = " studs" }):OnChanged(function(Value) SilentAimSettings.Tracer_Y_Offset = Value end)
local PredictionGroupBox = Tabs.Main:AddLeftGroupbox("预判"); PredictionGroupBox:AddToggle("PredictionToggle", { Text = "Mouse.Hit/Target 预判", Default = SilentAimSettings.MouseHitPrediction }):OnChanged(function(Value) SilentAimSettings.MouseHitPrediction = Value end); PredictionGroupBox:AddSlider("PredictionAmountSlider", { Text = "预判量", Min = 0, Max = 1, Default = SilentAimSettings.MouseHitPredictionAmount, Rounding = 3 }):OnChanged(function(Value) SilentAimSettings.MouseHitPredictionAmount = Value; PredictionAmount = Value end)
local MiscGroupBox = Tabs.Misc:AddLeftGroupbox("杂项"); MiscGroupBox:AddToggle("OptimizeToggle", { Text = "优先选择最近目标", Default = SilentAimSettings.OptimizeForDistance }):OnChanged(function(Value) SilentAimSettings.OptimizeForDistance = Value end); MiscGroupBox:AddDropdown("TargetInfoStyleDropdown", { Text = "信息显示样式", Default = SilentAimSettings.TargetInfoStyle, Values = {"面板", "头顶", "独立面板"} }):OnChanged(function(Value) SilentAimSettings.TargetInfoStyle = Value end); MiscGroupBox:AddToggle("LockPanelToggle", { Text = "锁定面板位置", Default = SilentAimSettings.LockPanelPosition, Compact = true }):OnChanged(function(Value) SilentAimSettings.LockPanelPosition = Value; DraggableInfoPanel.Draggable = not Value end); MiscGroupBox:AddToggle("RandomDamageColorToggle", { Text = "伤害颜色随机", Default = SilentAimSettings.RandomDamageColor, Compact = true}):OnChanged(function(Value) SilentAimSettings.RandomDamageColor = Value end); MiscGroupBox:AddToggle("ShowTargetNameToggle", { Text = "显示目标名字", Default = SilentAimSettings.ShowTargetName }):OnChanged(function(Value) SilentAimSettings.ShowTargetName = Value end); MiscGroupBox:AddToggle("ShowTargetHealthToggle", { Text = "显示目标血量", Default = SilentAimSettings.ShowTargetHealth }):OnChanged(function(Value) SilentAimSettings.ShowTargetHealth = Value end); MiscGroupBox:AddToggle("ShowTargetDistanceToggle", { Text = "显示目标距离", Default = SilentAimSettings.ShowTargetDistance }):OnChanged(function(Value) SilentAimSettings.ShowTargetDistance = Value end)

FOVCircleGui.Enabled = Toggles.FOVVisibleToggle.Value; FOVStroke.Color = Options.FOVColorPicker.Value; FOVCircleFrame.Size = UDim2.fromOffset(Options.FOVRadiusSlider.Value * 2, Options.FOVRadiusSlider.Value * 2)
task.spawn(function() while task.wait(2) do if SilentAimSettings.TargetMode ~= "玩家" then updateNPCs() end end end)

resume(create(function()
    RenderStepped:Connect(function()
        if SilentAimSettings.IndicatorRotationEnabled then currentRotationAngle = (currentRotationAngle + (SilentAimSettings.IndicatorRotationSpeed / 50)) % (math.pi * 2) end
        if SilentAimSettings.IndicatorRainbowEnabled then currentIndicatorHue = (currentIndicatorHue + (SilentAimSettings.IndicatorRainbowSpeed / 200)) % 1 end
        
        hideAllVisuals()
        
        local isEnabled = Toggles.EnabledToggle.Value
        local isLocked = false
        local targetCharacter = nil
        currentTargetPart = nil

        if isEnabled then
            local localRoot = LocalPlayer.Character and FindFirstChild(LocalPlayer.Character, "HumanoidRootPart")
            if localRoot then
                local targetPool = {}
                if SilentAimSettings.TargetMode ~= "NPC" then for _, p in ipairs(GetPlayers(Players)) do if p ~= LocalPlayer and not (SilentAimSettings.TeamCheck and p.Team == LocalPlayer.Team) then table.insert(targetPool, p) end end end
                if SilentAimSettings.TargetMode ~= "玩家" then for _, n in ipairs(npcList) do table.insert(targetPool, n) end end
                
                local availableTargets = getAllTargetsInFov(targetPool, localRoot)
                
                local dropdownNames = {"无"}; for _, t in ipairs(availableTargets) do table.insert(dropdownNames, t.name) end
                if not table_equal(dropdownNames, Options.TargetSelectionDropdown.Values) then Options.TargetSelectionDropdown:SetValues(dropdownNames) end

                local selectedName = Options.TargetSelectionDropdown.Value

                if selectedName and selectedName ~= "无" then
                    for _, targetData in ipairs(availableTargets) do
                        if targetData.name == selectedName then
                            targetCharacter = targetData.character
                            isLocked = true
                            break
                        end
                    end
                    if not targetCharacter then Options.TargetSelectionDropdown:Set("无") end 
                else
                    targetCharacter = getBestTarget(availableTargets)
                end

                if targetCharacter then
                    if SilentAimSettings.VisiblePartOverride then
                        currentTargetPart = getVisiblePart(targetCharacter) or getTargetPart(targetCharacter)
                    else
                        currentTargetPart = getTargetPart(targetCharacter)
                    end
                end
            end
        else
            Options.TargetSelectionDropdown:SetValues({"无"})
        end
        
        if currentTargetPart and currentTargetPart.Parent then
            local humanoid = currentTargetPart.Parent:FindFirstChildOfClass("Humanoid")
            if humanoid and targetHealthCache[humanoid] and humanoid.Health < targetHealthCache[humanoid] then
                local screenPos, onScreen = getPositionOnScreen(currentTargetPart.Position); if onScreen then ShowDamageIndicator(screenPos, targetHealthCache[humanoid] - humanoid.Health) end
            end
            if humanoid then targetHealthCache[humanoid] = humanoid.Health end
            
            local RootToViewportPoint, IsOnScreen = getPositionOnScreen(currentTargetPart.Position)
            if IsOnScreen then
                local indicatorRadius = SilentAimSettings.TargetIndicatorRadius
                local finalIndicatorColor = (isLocked and Color3.fromRGB(255, 0, 255)) or (SilentAimSettings.IndicatorRainbowEnabled and Color3.fromHSV(currentIndicatorHue, 1, 1)) or Options.TargetIndicatorColorPicker.Value
                if Toggles.ShowTargetToggle.Value then
                    local indicatorStyle = Options.IndicatorStyleDropdown.Value
                    if indicatorStyle == "Circle" then target_indicator_circle.Visible = true; target_indicator_circle.Color = finalIndicatorColor; target_indicator_circle.Radius = indicatorRadius; target_indicator_circle.Position = RootToViewportPoint
                    elseif indicatorStyle == "Triangle" then local points = getPolygonPoints(RootToViewportPoint, indicatorRadius, 3); for i = 1, 3 do local line = target_indicator_lines[i]; line.Visible = true; line.Color = finalIndicatorColor; line.From = points[i]; line.To = points[i % 3 + 1] end
                    elseif indicatorStyle == "Pentagram" then local points = getPolygonPoints(RootToViewportPoint, indicatorRadius, 5); local pentagram_order = {1, 3, 5, 2, 4}; for i = 1, 5 do local line = target_indicator_lines[i]; line.Visible = true; line.Color = finalIndicatorColor; line.From = points[pentagram_order[i]]; line.To = points[pentagram_order[i % 5 + 1]] end end
                end
                
                local showAnyInfo = Toggles.ShowTargetNameToggle.Value or Toggles.ShowTargetHealthToggle.Value or Toggles.ShowTargetDistanceToggle.Value
                if showAnyInfo and currentTargetPart.Parent then
                    local char = currentTargetPart.Parent; local player = Players:GetPlayerFromCharacter(char); local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                    local hum = char and char:FindFirstChildOfClass("Humanoid")
                    if hum and localRoot then
                        local targetName = player and player.DisplayName or char.Name; local health = math.floor(hum.Health); local dist = math.floor((localRoot.Position - currentTargetPart.Position).Magnitude); local infoStyle = SilentAimSettings.TargetInfoStyle
                        if infoStyle == "独立面板" then
                            DraggableInfoPanel.Visible = true
                            DraggableInfoName.Visible = Toggles.ShowTargetNameToggle.Value; if Toggles.ShowTargetNameToggle.Value then DraggableInfoName.Text = targetName end
                            DraggableInfoHealth.Visible = Toggles.ShowTargetHealthToggle.Value; if Toggles.ShowTargetHealthToggle.Value then DraggableInfoHealth.Text = string.format("血量: %d", health) end
                            DraggableInfoDistance.Visible = Toggles.ShowTargetDistanceToggle.Value; if Toggles.ShowTargetDistanceToggle.Value then DraggableInfoDistance.Text = string.format("距离: %dm", dist) end
                        elseif infoStyle == "面板" then
                            local linesDrawn = 0; local lineHeight = 15; local infoPos = RootToViewportPoint + Vector2.new(indicatorRadius + 5, -22)
                            if Toggles.ShowTargetNameToggle.Value then local textObj = panel_info_texts.Name; textObj.Text = targetName; textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                            if Toggles.ShowTargetHealthToggle.Value then local textObj = panel_info_texts.Health; textObj.Text = string.format("血量: %d", health); textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                            if Toggles.ShowTargetDistanceToggle.Value then local textObj = panel_info_texts.Distance; textObj.Text = string.format("距离: %dm", dist); textObj.Position = infoPos + Vector2.new(5, 5 + (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                            if linesDrawn > 0 then panel_info_bg.Position = infoPos; panel_info_bg.Size = Vector2.new(120, 10 + (linesDrawn * lineHeight)); panel_info_bg.Visible = true end
                        elseif infoStyle == "头顶" then
                            local linesDrawn = 0; local lineHeight = 15; local base_y = RootToViewportPoint.Y - indicatorRadius - 10
                            if Toggles.ShowTargetNameToggle.Value then local textObj = overhead_info_texts.Name; textObj.Text = string.format("[%s]", targetName); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                            if Toggles.ShowTargetHealthToggle.Value then local textObj = overhead_info_texts.Health; textObj.Text = string.format("[%d]", health); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                            if Toggles.ShowTargetDistanceToggle.Value then local textObj = overhead_info_texts.Distance; textObj.Text = string.format("[%dm]", dist); textObj.Position = Vector2.new(RootToViewportPoint.X, base_y - (linesDrawn * lineHeight)); textObj.Visible = true; linesDrawn = linesDrawn + 1 end
                        end
                    end
                end
            end
        else
            if SilentAimSettings.TargetInfoStyle == "独立面板" then
                 DraggableInfoName.Visible = false; DraggableInfoHealth.Visible = false; DraggableInfoDistance.Visible = false
            end
        end

        if Toggles.ShowTracerToggle.Value and isEnabled and currentTargetPart then
            local tracerTargetPosition = currentTargetPart.Position; local y_offset = SilentAimSettings.Tracer_Y_Offset; local finalTracerPosition = tracerTargetPosition - Vector3.new(0, y_offset, 0); local targetScreenPos, IsOnScreen = getPositionOnScreen(finalTracerPosition); tracer_line.Visible = IsOnScreen; if IsOnScreen then tracer_line.From = Camera.ViewportSize / 2; tracer_line.To = targetScreenPos; tracer_line.Color = Options.TracerColorPicker.Value end
        else
            tracer_line.Visible = false
        end
        
        if Toggles.FOVVisibleToggle.Value then if Toggles.FixedFOVToggle.Value then FOVCircleFrame.Position = UDim2.fromScale(0.5, 0.5) else local mousePos = GetMouseLocation(UserInputService); FOVCircleFrame.Position = UDim2.fromOffset(mousePos.X, mousePos.Y) end end
    end)
end))

local oldNamecall; oldNamecall = hookmetamethod(game, "__namecall", newcclosure(function(...) local Method = getnamecallmethod(); local Arguments = {...}; local self = Arguments[1]; if SilentAimSettings.Enabled and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) and currentTargetPart then local currentMethod = SilentAimSettings.SilentAimMethod; if Method == "FindPartOnRayWithIgnoreList" and currentMethod == Method then if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithIgnoreList) then local A_Ray = Arguments[2]; Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, currentTargetPart.Position)); return oldNamecall(unpack(Arguments)) end elseif Method == "FindPartOnRayWithWhitelist" and currentMethod == Method then if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRayWithWhitelist) then local A_Ray = Arguments[2]; Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, currentTargetPart.Position)); return oldNamecall(unpack(Arguments)) end elseif (Method == "FindPartOnRay" or Method == "findPartOnRay") and currentMethod:lower() == Method:lower() then if ValidateArguments(Arguments, ExpectedArguments.FindPartOnRay) then local A_Ray = Arguments[2]; Arguments[2] = Ray.new(A_Ray.Origin, getDirection(A_Ray.Origin, currentTargetPart.Position)); return oldNamecall(unpack(Arguments)) end elseif Method == "Raycast" and currentMethod == Method then if ValidateArguments(Arguments, ExpectedArguments.Raycast) then Arguments[3] = getDirection(Arguments[2], currentTargetPart.Position); return oldNamecall(unpack(Arguments)) end elseif (Method == "ScreenPointToRay" or Method == "ViewportPointToRay") and currentMethod == Method and self == Camera then local origin = Camera.CFrame.Position; local direction = (currentTargetPart.Position - origin).Unit; return Ray.new(origin, direction) end end; return oldNamecall(...) end))
local oldIndex; local oldRayNew; oldIndex = hookmetamethod(game, "__index", newcclosure(function(self, Index) if self == Mouse and not checkcaller() and SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Mouse.Hit/Target" then if currentTargetPart then if Index == "Target" or Index == "target" then return currentTargetPart elseif Index == "Hit" or Index == "hit" then return (SilentAimSettings.MouseHitPrediction and (currentTargetPart.CFrame + (currentTargetPart.Velocity * currentTargetPart.Velocity.magnitude * SilentAimSettings.MouseHitPredictionAmount))) or currentTargetPart.CFrame elseif Index == "X" or Index == "x" then return self.X elseif Index == "Y" or Index == "y" then return self.Y elseif Index == "UnitRay" then return Ray.new(self.Origin, (self.Hit.p - self.Origin.p).Unit) end end end; return oldIndex(self, Index) end)); oldRayNew = hookfunction(Ray.new, newcclosure(function(origin, direction) if SilentAimSettings.Enabled and SilentAimSettings.SilentAimMethod == "Ray" and currentTargetPart and not checkcaller() and CalculateChance(SilentAimSettings.HitChance) then local newDirectionVector = getDirection(origin, currentTargetPart.Position); return oldRayNew(origin, newDirectionVector) end; return oldRayNew(origin, direction) end))

Library:OnUnload(function() FOVCircleGui:Destroy(); hideAllVisuals() end)
ThemeManager:SetLibrary(Library); SaveManager:SetLibrary(Library); SaveManager:IgnoreThemeSettings(); SaveManager:SetIgnoreIndexes({ "MenuKeybind" }); SaveManager:SetFolder("UniversalSilentAim/Configs"); SaveManager:BuildConfigSection(Tabs["UI Settings"]); ThemeManager:ApplyToTab(Tabs["UI Settings"]); SaveManager:LoadAutoloadConfig()
